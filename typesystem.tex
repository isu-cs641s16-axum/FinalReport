\section{Type System}
\label{sec:types}

We have defined a number of new types to fit into our formalization model and we will discuss them one by one. The schema of the relations are defined as a type.
\begin{figure}
\begin{center}
$\begin{array}{@{}l@{~}l@{\quad}l@{\!\!\!\!\!\!}r}
schema\_ty : Set := & \ \ \ \ \ & \emph{Schema} \\
& \quad \mid STyNil: & schema\_ty\\
& \quad \mid STyPair: & col\_ty \rightarrow schema\_ty \rightarrow schema\_ty\\
with \:col\_ty : Set := & & \\
& \quad \mid CTyNat: & col\_ty\\
& \quad \mid CTyBag: & schema\_ty \rightarrow col\_ty. \\
\end{array}
$
\end{center}
\caption{Schema Types}
\label{fig-schema_types}
\end{figure}
Schema in our formalization can be constructed from a pair of column type and another schema and STyNil is used as a schema terminator. The column type can be an atomic attribute or it can be another complex schema as well. We have also defined four basic types - TUnit, TFn, TPred, TSchema. Tunit is the unit type used as the type for statements. TFn and TPred are used for functions and predicates respectively and they take schema types as argument to produce the new types.

\begin{figure}
\begin{center}
$\begin{array}{@{}l@{~}l@{\quad}l@{\!\!\!\!\!\!}r}
ty : Set := & \ \ \ \ \ & \emph{Types} \\
& \quad \mid TUnit: & ty\\
& \quad \mid TFn: & schema\_ty \rightarrow schema\_ty \rightarrow ty\\
& \quad \mid TPred: & schema\_ty \rightarrow ty\\
& \quad \mid TSchema: & schema\_ty \rightarrow ty. \\
\end{array}
$
\end{center}
\caption{Types}
\label{fig-types}
\end{figure} 

\begin{figure}
\begin{center}
	$\begin{array}{@{}l@{~}l@{\quad}l@{\!\!\!\!\!\!}r}
	udf : ty \rightarrow \:Prop := & \ \ \ \ \ & \emph{UDF} \\
	& \quad \mid UDFTFn: & Function Type\\
	& \quad \mid UDFTPred: & Predicate Type\\
	\end{array}$
\end{center}
\caption{Types -UDF}
\label{fig-udf}
\end{figure}

\begin{figure}
\begin{center}
	$\begin{array}{@{}l@{~}l@{\quad}l@{\!\!\!\!\!\!}r}
	loadable : ty \rightarrow \:Prop := & \ \ \ \ \ & \emph{Loables Types} \\
	& \quad \mid LTSchema: & Loadable Schema\\
	& \quad \mid LTUDF: & Loadable UDFs\\
	\end{array}$
\end{center}
\caption{Types -Loadable}
\label{fig-loadable}
\end{figure} 

The only valid UDFs allowed in our formalization are functions and predicates and the variety in UDFs are constrained by specifying the udf types. Similarly the only allowed loadable types are either a schema or an UDF that can be assigned to an identifier using the load statement.

The terms defined in the formalized are mentioned as below:

\begin{figure}
\begin{center}
$\begin{array}{@{}l@{~}l@{\quad}l@{\!\!\!\!\!\!}r}
tm : Set := & \ \ \ \ \ & \emph{Terms} \\
& \quad \mid t\_filter: & id \rightarrow \:id \rightarrow \:tm\\
& \quad \mid t\_foreach: & id \rightarrow \:id \rightarrow \:tm\\
& \quad \mid t\_group: & id \rightarrow \:col \rightarrow \:tm\\
& \quad \mid t\_join: & id \rightarrow \:col \rightarrow \:id \rightarrow \:col \rightarrow \:tm\\
& \quad \mid t\_load: & id \rightarrow \:ty \rightarrow \:tm\\
& \quad \mid t\_assign: & id \rightarrow \:tm \rightarrow \:tm\\
& \quad \mid t\_store: & id \rightarrow \:tm\\
& \quad \mid t\_seq: & tm \rightarrow \:tm \rightarrow \:tm\\
\end{array}
$
\end{center}
\caption{Terms}
\label{fig-terms}
\end{figure}

\begin{figure}
\centering
	\begin{minipage}{.4\textwidth}
	\begin{flushleft}
		\begin{mathpar}
		\inferrule* [lab = T\_Filter]
          	{\Gamma \vdash x \in TSchema \:S \\ 
          	\Gamma \vdash y \in TPred \:S} 
          	{\Gamma \vdash FILTER \:x \:y \in TSchema \:S }
        \end{mathpar}
        \captionof{figure}{Typing Rules for FILTER}
  		\label{fig:filter}
	\end{flushleft}
    \end{minipage}
%		\hva \and
	\begin{minipage}{.4\textwidth}
	\begin{flushright}
		\begin{mathpar}
		\inferrule* [lab = T\_ForEach]
          	{\Gamma \vdash x \in TSchema \:S \\ \Gamma \vdash y \in TFn\: S\:S'} 
			{\Gamma \vdash FOREACH \:x\:y \in TSchema \:S' }
		\end{mathpar}
		\captionof{figure}{Typing Rules for FOREACH}
		\label{fig:foreach}
	\end{flushright}
	\end{minipage}
\end{figure}


\begin{figure}
\centering
	\begin{mathpar}
		\inferrule* [Right= \quad T\_Group]
          		{\Gamma \vdash x \in TSchema \:S \\\\
          		\:S \:[c] \in \:CTyNat} 
          		{\Gamma \vdash GROUP \:x \:c \in TSchema (CTyNat \:***(CTyBag \:S)\:***) }
	\end{mathpar}
  \captionof{figure}{Typing Rule for GROUP}
  \label{fig:group}
\end{figure}

\begin{figure}
  \centering
	\begin{mathpar}
		\inferrule* [Right= \quad T\_Join]
          		{\Gamma \vdash x \in TSchema \:S_1 \\ \Gamma \vdash y \in  TSchema \:S_2 \\\\
		 		S_1 \:[c_x] \in \:CTyNat \\ \:S_2 \:[c_y] \in \:CTyNat \\\\
		 		\:S_3 = \:S_1 +++ \:S_2} 
		 		{\Gamma \vdash JOIN \:x \:c_x \:y \:c_y \in TSchema \:S_3 }
	\end{mathpar}
  \captionof{figure}{Typing Rule for Join}
  \label{fig:join}
\end{figure}


\begin{figure}
\centering
	\begin{minipage}{.4\textwidth}
	\begin{flushleft}
		\begin{mathpar}
		\inferrule* [lab= T\_Load]
          		{\Gamma \vdash x = None \\ loadable\: T} 
          		{\Gamma \vdash LOAD \:x\:T \in TUnit }
        \end{mathpar}
        \captionof{figure}{Typing Rules for LOAD}
  		\label{fig:load}
	\end{flushleft}
    \end{minipage}
%		\hva \and
	\begin{minipage}{.4\textwidth}
	\begin{flushright}
		\begin{mathpar}
		\inferrule* [lab= T\_Store]
				{\Gamma \vdash x \in TSchema \:S} 
				{\Gamma \vdash STORE \:x \in TUnit }
		\end{mathpar}
		\captionof{figure}{Typing Rules for STORE}
		\label{fig:store}
	\end{flushright}
	\end{minipage}
\end{figure}

\begin{figure}
\centering
	\begin{mathpar}
		\inferrule* [Right=\quad\: T\_Assign]
          		{\Gamma \vdash x = None \\ \Gamma \vdash q \in TSchema \:S} 
          		{\Gamma \vdash \:x ::= \:q \in TUnit }\\
	\end{mathpar}
  \captionof{figure}{Typing Rules for ASSIGN}
  \label{fig:assign}
\end{figure}


\begin{figure}
\centering
	\begin{minipage}{.4\textwidth}
	\begin{flushleft}
		\begin{mathpar}
		\inferrule* [lab= T\_SeqLoad]
          		{s_1 = LOAD \:x \:T \\ \Gamma \vdash s_1 \in TUnit \\\\
          		\Gamma, x:T \vdash s_2 \in TUnit } 
          		{\Gamma \vdash \:s_1 \: ;; \:s_2 \in TUnit }\\
        \end{mathpar}
        \captionof{figure}{Typing Rules for SEQLOAD}
  		\label{fig:seqload}
	\end{flushleft}
    \end{minipage}
%		\hva \and
	\begin{minipage}{.4\textwidth}
	\begin{flushright}
		\begin{mathpar}
		\inferrule* [lab= T\_SeqStore]
          	{s_1 = STORE \:x \\\\
          	\Gamma \vdash x \in\: TSchema \:S \\\\ 
			\Gamma \vdash s_1 \in TUnit \\ \Gamma \vdash s_2 \in TUnit } 
			{\Gamma \vdash \:s_1 \: ;; \:s_2 \in TUnit }
		\end{mathpar}
		\captionof{figure}{Typing Rules for SEQSTORE}
		\label{fig:seqstore}
	\end{flushright}
	\end{minipage}
\end{figure}

\begin{figure}
\centering
	\begin{mathpar}
		\inferrule* [Right= \quad T\_SeqAssign]
          		{s_1 = (\:x ::= \:q) \\\\
          		\Gamma \vdash q \in TSchema \:S \\\\
          		\Gamma \vdash s_1 \in TUnit \\ \Gamma, x: TSchema \:S \vdash s_2 \in TUnit} 
          		{\Gamma \vdash \:s_1 \: ;; \:s_2 \in TUnit }
	\end{mathpar}
  \captionof{figure}{Typing Rule for SEQASSIGN}
  \label{fig:seqassign}
\end{figure}


\begin{figure}
\centering
	\begin{minipage}{.4\textwidth}
	\begin{flushleft}
		\begin{mathpar}
		\inferrule* [lab = T\_LReArrange]
          		{\Gamma \vdash x \in \: TSchema \:S \\\\ 
          		S \:[c] \in\:CTyNat} 
          		{\Gamma \vdash LReArrange \:x\:c \in TSchema \:S }
        \end{mathpar}
        \captionof{figure}{Typing Rules for LOCAL REARRANGE}
  		\label{fig:lrearrange}
	\end{flushleft}
    \end{minipage}
%		\hva \and
	\begin{minipage}{.4\textwidth}
	\begin{flushright}
		\begin{mathpar}
		\inferrule* [lab = T\_GReArrange]
          		{\Gamma \vdash x \in\: TSchema \:S \\\\ 
          		S \:[c] \in\:CTyNat} 
          		{\Gamma \vdash GReArrange \:x\:c \in TSchema \:S }
    	\end{mathpar}
		\captionof{figure}{Typing Rules for GLOBAL REARRANGE}
		\label{fig:grearrange}
	\end{flushright}
	\end{minipage}
\end{figure}

\begin{figure}
\centering
	\begin{mathpar}
		\inferrule* [Right= \quad T\_Package]
          		{\Gamma \vdash x \in \:TSchema \:S \\\\ 
          		S \:[c] \in\:CTyNat} 
          		{\Gamma \vdash PACKAGE \:x \:c \in TSchema( CTyNat \:*** \:(CTyBag \:S)\:***) \: }
	\end{mathpar}
  \captionof{figure}{Typing Rule for Package}
  \label{fig:package}
\end{figure}


{\bf TODO: present the new types, and the type rules here, and description of 
these rules that focuses on the new and interesting rules.}

